# 클라이언트 사이드 합성 분석

## 현재 구조

### 서버 사이드 (현재)
1. MuseTalk 모델로 256x256 크롭된 얼굴 프레임 생성
2. 원본 비디오 프레임과 블렌딩 (face parsing 마스크 사용)
3. 선명화, 리사이즈, 페이드 처리
4. 최종 프레임을 JPEG (85% 품질)로 인코딩 → Base64 → 클라이언트 전송

### 제안: 클라이언트 사이드 합성
1. 서버: 크롭된 얼굴 프레임만 생성 (256x256)
2. 서버: 원본 비디오 프레임 전송 (초기 1회 또는 주기적)
3. 서버: 블렌딩 좌표 (bbox) 전송
4. 클라이언트: Canvas API로 블렌딩 수행

---

## 장점 ✅

### 1. **네트워크 대역폭 절감** (가장 큰 이점)
- **현재**: 전체 프레임 (예: 1280x720) JPEG 인코딩 → ~50-100KB/프레임
- **개선**: 크롭된 얼굴만 (256x256) → ~5-10KB/프레임
- **절감률**: **80-90% 대역폭 절감**
- **효과**: 느린 네트워크에서도 빠른 전송, 모바일 데이터 절약

### 2. **서버 CPU/GPU 부하 감소**
- 블렌딩 작업 제거 (OpenCV 연산)
- JPEG 인코딩 부하 감소 (작은 이미지만 인코딩)
- **예상 효과**: 서버 CPU 사용률 20-30% 감소

### 3. **확장성 향상**
- 서버가 더 많은 동시 사용자 처리 가능
- 서버 리소스 절약으로 비용 감소

### 4. **스트리밍 지연 감소**
- 작은 이미지 전송으로 네트워크 지연 감소
- 클라이언트에서 병렬 처리 가능

---

## 단점 및 문제점 ⚠️

### 1. **클라이언트 CPU 부하 증가** (중요)
- **문제**: 브라우저에서 Canvas API로 블렌딩 수행
- **영향**: 
  - 저사양 기기에서 프레임 드롭 발생 가능
  - 모바일 기기에서 배터리 소모 증가
  - 다른 브라우저 탭 성능 저하

### 2. **블렌딩 품질 저하** (중요)
- **현재**: OpenCV의 고급 블렌딩 (face parsing 마스크, 가우시안 블러)
- **클라이언트**: Canvas API의 기본 블렌딩만 가능
  - `globalCompositeOperation = 'source-over'` (단순 오버레이)
  - 마스크 기반 블렌딩 어려움
  - 경계 부드럽게 처리 어려움
- **결과**: 얼굴 경계가 어색할 수 있음

### 3. **구현 복잡도 증가**
- **서버**: 
  - 원본 비디오 프레임 전송 로직 추가
  - 블렌딩 좌표 전송
  - 초기 프레임 로드 또는 주기적 업데이트
- **클라이언트**:
  - Canvas API 블렌딩 로직 구현
  - 프레임 동기화 처리
  - 오류 처리 및 폴백

### 4. **원본 비디오 프레임 전송 필요**
- **문제**: 원본 비디오 프레임도 전송해야 함
- **옵션 1**: 초기 1회 전송 (메모리 사용)
- **옵션 2**: 주기적 전송 (네트워크 부하)
- **옵션 3**: 클라이언트에 비디오 파일 제공 (초기 로드 시간)

### 5. **브라우저 호환성**
- Canvas API는 모든 브라우저에서 지원되지만
- 성능 차이가 큼 (Chrome vs Safari vs Firefox)
- 모바일 브라우저에서 성능 저하 가능

### 6. **보안 및 프라이버시**
- 원본 비디오 프레임이 클라이언트에 전송됨
- 클라이언트에서 비디오 추출 가능

### 7. **디버깅 어려움**
- 클라이언트에서 블렌딩 오류 발생 시 추적 어려움
- 서버-클라이언트 동기화 문제

---

## 성능 비교 예상

### 현재 (서버 사이드)
- **블렌딩 시간**: ~10-20ms/프레임 (서버 CPU)
- **JPEG 인코딩**: ~5-10ms/프레임 (서버 CPU)
- **네트워크 전송**: ~50-100KB/프레임
- **총 서버 시간**: ~15-30ms/프레임

### 클라이언트 사이드 (예상)
- **서버**: 크롭 프레임 생성만 → ~0ms 추가 (이미 생성됨)
- **네트워크 전송**: ~5-10KB/프레임 (80-90% 절감)
- **클라이언트 블렌딩**: ~5-15ms/프레임 (브라우저 성능에 따라)
- **총 클라이언트 시간**: ~5-15ms/프레임

### 예상 효과
- **네트워크**: 80-90% 절감 ✅
- **서버 부하**: 20-30% 감소 ✅
- **클라이언트 부하**: 증가 ⚠️
- **품질**: 약간 저하 가능 ⚠️

---

## 구현 방안

### 옵션 1: 하이브리드 방식 (권장)
- **짧은 텍스트**: 서버 사이드 (품질 우선)
- **긴 텍스트**: 클라이언트 사이드 (속도 우선)
- 사용자가 선택 가능

### 옵션 2: 품질 설정
- **High Quality**: 서버 사이드 블렌딩
- **Fast Mode**: 클라이언트 사이드 블렌딩

### 옵션 3: 기기 성능 감지
- 고성능 기기: 클라이언트 사이드
- 저성능 기기: 서버 사이드

---

## 권장 사항

### ✅ 구현 권장 (하이브리드)
1. **초기 구현**: 클라이언트 사이드 옵션 추가
2. **사용자 선택**: 설정에서 모드 선택 가능
3. **자동 감지**: 기기 성능에 따라 자동 선택

### ⚠️ 주의사항
1. **품질 검증**: 클라이언트 블렌딩 품질이 허용 가능한지 확인
2. **성능 테스트**: 다양한 기기에서 테스트 필요
3. **폴백 제공**: 클라이언트 블렌딩 실패 시 서버 사이드로 폴백

---

## 구현 예시

### 서버 사이드 변경
```python
# 크롭된 얼굴 프레임만 전송
emit_callback('stream_cropped_frame', {
    'frame': cropped_frame_base64,  # 256x256
    'bbox': [x1, y1, x2, y2],
    'original_frame_index': idx,
    'index': i
}, to=sid)

# 원본 프레임은 초기 1회 또는 주기적 전송
if i == 0 or i % 30 == 0:  # 30프레임마다
    emit_callback('stream_original_frame', {
        'frame': original_frame_base64,
        'index': idx
    }, to=sid)
```

### 클라이언트 사이드 구현
```javascript
// Canvas 블렌딩
function blendFrame(originalFrame, croppedFrame, bbox) {
    const canvas = document.createElement('canvas');
    canvas.width = originalFrame.width;
    canvas.height = originalFrame.height;
    const ctx = canvas.getContext('2d');
    
    // 원본 프레임 그리기
    ctx.drawImage(originalFrame, 0, 0);
    
    // 크롭된 얼굴 프레임 블렌딩
    const [x1, y1, x2, y2] = bbox;
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(croppedFrame, x1, y1, x2 - x1, y2 - y1);
    
    return canvas;
}
```

---

## 결론

### 속도 향상: ✅ 예상됨
- 네트워크 전송 시간 80-90% 감소
- 서버 부하 감소로 더 빠른 처리 가능

### 문제점: ⚠️ 주의 필요
- 클라이언트 CPU 부하 증가
- 블렌딩 품질 저하 가능
- 구현 복잡도 증가

### 최종 권장: 하이브리드 방식
- 사용자 선택 또는 기기 성능에 따라 자동 선택
- 품질이 중요한 경우 서버 사이드 유지
- 속도가 중요한 경우 클라이언트 사이드 사용
